{% extends 'base.html' %}

{% block title %}
Page Replacement
{% endblock %}

{% block style %}
<style>
    body {
        font-family: 'Arial', sans-serif;
        background-color: #f3f4f6;
        color: #111;
    }

    h1, h2 {
        text-align: center;
        font-weight: 700;
        margin-top: 30px;
        color: #0a4b78;
    }

    section {
        text-align: justify;
        text-justify: inter-word;
        margin: 40px auto;
        max-width: 1000px;
        padding: 30px 50px;
        background-color: rgba(144, 213, 255, 0.3);
        border-radius: 12px;
        box-shadow: 0 0 15px rgba(0, 0, 139, 0.2);
    }

    .info-card {
        display: flex;
        flex-direction: column;
        justify-content: center;
        background-color: #F0F8FF;
        transition: transform 0.3s ease;
        margin-top: 20px;
        padding: 20px;
        border-radius: 10px;
    }

    .info-card:hover {
        transform: scale(1.02);
    }
</style>
{% endblock %}

{% block body %}
<h1>Page Replacement</h1>

<section>
    <p>In operating systems, page replacement algorithms are used when a requested page is not in memory (a page fault), and the system must decide which page to remove to make space for the new one. The goal is to reduce the number of page faults by choosing the best page to evict.</p>

    <h2>Basic Concepts</h2>
    <p>When a process executes, it requires pages to be loaded into memory. If there are no free frames and a new page needs to be loaded, the operating system must decide which existing page to remove. This decision is made by the page replacement algorithm.</p>

    <p>A good page replacement algorithm reduces the rate of page faults. Common strategies include:</p>

    <section class="info-card">
        <h3>FIFO (First-In-First-Out)</h3>
        <p>The oldest page in memory (the one loaded earliest) is removed first. It's simple but not always effective, as it may remove frequently used pages, leading to high page fault rates (this is known as Belady’s Anomaly).</p>
    </section>

    <section class="info-card">
        <h3>LRU (Least Recently Used)</h3>
        <p>This algorithm removes the page that hasn’t been used for the longest time. It is based on the assumption that pages used recently will likely be used again soon. LRU provides better performance but can be expensive to implement.</p>
    </section>

    <section class="info-card">
        <h3>Optimal Page Replacement</h3>
        <p>This is a theoretical model where the system replaces the page that won’t be used for the longest time in the future. While it offers the best possible page fault rate, it requires future knowledge of memory references and is impractical in real systems. It's mainly used for comparison.</p>
    </section>

    <section class="info-card">
        <h3>Clock (Second Chance)</h3>
        <p>This is an efficient approximation of LRU. Pages are arranged in a circular buffer with a reference bit. If a page's bit is set to 0, it is replaced; if it’s 1, the bit is cleared and the pointer moves to the next page. This continues until a page with bit 0 is found.</p>
    </section>

    <section class="info-card">
        <h3>Counting-Based Algorithms</h3>
        <p>These include LFU (Least Frequently Used), which removes the page with the lowest access count, and MFU (Most Frequently Used), which does the opposite. However, they may not always reflect actual usage patterns and can be inaccurate or unfair.</p>
    </section>

    <h2>Performance Metrics</h2>
    <ul>
        <li><b>Page Fault Rate:</b> The ratio of page faults to total memory accesses. Lower is better.</li>
        <li><b>Implementation Complexity:</b> Some algorithms, like LRU, need complex tracking mechanisms.</li>
        <li><b>Overhead:</b> Algorithms should not consume excessive system resources.</li>
    </ul>

    <p>Choosing the right page replacement algorithm depends on the system’s needs, available hardware support, and access patterns of the applications running.</p>
</section>
{% endblock %}
